<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>SISL</title>
    <style>
        canvas {
            padding-left: 0;
            padding-right: 0;
            margin-left: auto;
            margin-right: auto;
            display: block;
        }
        #formholder {
           text-align: center;
        }
        table.consent {
            border: 1px solid gray;
            border-collapse: collapse;
            margin: 10px;
            padding: 10px;
            margin-left: auto;
            margin-right: auto;
        }
        table.consent td {
            text-align: left;
            padding: 10px;
        }
        #acceptbutton {
            margin: 40px;
        }
    </style>
</head>
<body onload="main()">
<div id="formholder"></div>
<div>
    <canvas id="mainWin" width="800" height="600" style="border:1px solid #000000;"></canvas>
</div>

<script src="server.js"></script>
<script src="SISL_preload.js"></script>
<script src="cue_mover.js"></script>

<script>
    // Canvas required globals
    var canvas = document.getElementById("mainWin");
    var _version = "SISL.js 0.3 Jan 2016";
    var ctx = canvas.getContext("2d");
    var requestId = 0;

    // required globals -- response_log, cfg array for configuration information, images list of images
    var cfg = {};            // holds all configuration variable information
    var images = {};         // list of images to be used in experiment
    var response_log = [];   // list of log strings to be uploaded

    var sessionToken='';     // this will be parsed from the URL

    // SISL specific variables
    var layout = {
        width: canvas.width,
        height: canvas.height,
        cue_area: 650,
        feedback_area: 150,
        background: function() {
            // draw any background decorations
            ctx.fillStyle=cfg['background_color'];
            ctx.fillRect(0,0,this.width,this.height);
        },
        clear: function() {
            ctx.clearRect(0,0, this.width, this.height);
            this.background();
        },
    }

    var session = []; // holds the structure of the session information
    var session_state_counter=0;
    var session_state=0;
    var config_parsed=false;
    var initialized=false;
    var demo_mode=false;
    var cue_set = [];
    var lane_set = [];
    var anim_list = [];
    var current_speed=1.5;

    var break_image_file='';
    var block_start = window.performance.now();
    var last_launch = window.performance.now();
    var count = 0;
    var block_trial_max=0;
    var current_cue=0;

    var upload_in_progress=false;
    var uploaded_final=false;

    // speed adjustment object for increasing/decreasing speed based on performance
    var speed_adj = function(checkevery,thresholds,fraction){
        this.speed_trials_counter=0;
        this.speed_correct_counter=0;
        this.last_trial_scored= -1;
        this.checkevery=checkevery;
        this.thresh_down=thresholds[0]*this.checkevery;
        this.thresh_up=thresholds[1]*this.checkevery;
        this.fraction=fraction;
        this.score_correct=function(trial_num){
            if(trial_num>this.last_trial_scored){
                this.speed_trials_counter++;
                this.speed_correct_counter++;
                this.check_speed();
            }
        };
        this.score_incorrect=function(trial_num){
            if(trial_num>this.last_trial_scored){
                this.speed_trials_counter++;
                this.check_speed();
            }
        };
        this.check_speed=function(){
            if(this.speed_trials_counter>=this.checkevery){ // will need to update velocity for all activte cues
                var f=1.0;
                if(this.speed_correct_counter>this.thresh_up){
                    f=(this.fraction[0]/this.fraction[1]);
                    current_speed=current_speed*f;
                    log_event('faster',[current_cue,this.speed_correct_counter,this.thresh_up, f.toFixed(3)]);
                }
                else if(this.speed_correct_counter<this.thresh_down){
                    f=(this.fraction[1]/this.fraction[0]);
                    current_speed=current_speed*f;
                    log_event('slower',[current_cue,this.speed_correct_counter,this.thresh_up, f.toFixed(3)]);
                }
                if(f!=1.0){
                    // update the speed of each cue, velocity is inverted compared to speed
                    for(var i=0;i<cue_set.length;i++) cue_set[i].adjust_speed(1.0/f);
                }
                this.speed_trials_counter=0;
                this.speed_correct_counter=0;
            }
        }
    };

    var stats = {
        reset: function() {
            this.seq_trials=0;
            this.seq_correct=0;
            this.seq_pc=0;
            this.foil_trials=0;
            this.foil_correct=0;
            this.foil_pc=0;
            this.last_fps=window.performance.now();
            this.frame_count=0;
            this.fps=0;
            this.streak=0;
            this.longest_streak=0;
            this.sspa=0;
            this.score=0; // not implemented yet
        },
        count: function(stat_type){
            switch(stat_type) {
                case 'seq_correct':
                    this.seq_correct++;
                    this.seq_trials++;
                    this.streak++;
                    break;
                case 'seq_incorrect':
                    this.seq_trials++;
                    this.streak=0;
                    break;
                case 'foil_correct':
                    this.foil_correct++;
                    this.foil_trials++;
                    this.streak++;
                    break;
                case 'foil_incorrect':
                    this.foil_trials++;
                    this.streak=0;
                    break;
            }
            if(this.seq_trials>0) this.seq_pc=((this.seq_correct/this.seq_trials)*100);
            if(this.foil_trials>0) this.foil_pc=((this.foil_correct/this.foil_trials)*100);
            if(this.streak>this.longest_streak) this.longest_streak=this.streak;
            if(this.foil_pc>0 && this.seq_pc>0) this.sspa=this.seq_pc-this.foil_pc;
        },
        fps_update: function() {
            var curr_time=window.performance.now();
            this.fps=(this.frame_count*1000)/(curr_time-this.last_fps);
            this.last_fps=curr_time;
            this.frame_count=0;
        },
        fps_count: function() {
            this.frame_count++;
            if ((window.performance.now()-this.last_fps)>3000) this.fps_update();
        },
        hit_score: function(offset) {
            this.score+=100.0-Math.min(95,1520.0*(offset*offset));
        }
        // add score function, fps update
    }

    // class for holding shorter sequences as used in demo or recognition
    var Recognition =  {
        trial_num: 0,
        trial_length: 0,
        current_cue: 0,
        init_sequence: function(trial_num) {
            var begin = trial_num*this.trial_length;
            var end = begin+this.trial_length;
            this.cue_pattern=cfg['recognition_pattern'].slice(begin,(begin+this.trial_length));
            this.timing_pattern=cfg['recognition_timing'].slice(begin,(begin+this.trial_length));
            this.current_cue=0;
        },
    }

    function activate_pos_flash(key_lane) {
        for(var i=0;i<anim_list.length;i++) {
            if(anim_list[i].anim_type=='flash-pos' && anim_list[i].anim_args[0]==key_lane) {
                anim_list[i].active=true;
                anim_list[i].frame_count=0; // reset frame count just in case it is already active
                return;
            }
        }
    }

    function activate_neg_flash(key_lane) {
        for(var i=0;i<anim_list.length;i++) {
            if(anim_list[i].anim_type=='flash-neg' && anim_list[i].anim_args[0]==key_lane) {
                anim_list[i].active=true;
                anim_list[i].frame_count=0; // reset frame count just in case it is already active
                return;
            }
        }
    }

    // args[0] is trial_number, others are for passing to log_response
    function score_response(event_type,cue_index,key_lane,args){
        if(event_type=='hit'){ // args -- [cue_set[closest_index].trial_num, key, cue_set[closest_index].position.toFixed(3)]
            cue_set[cue_index].scored = true;
            var trial_num=cue_set[cue_index].trial_num;
            if(cfg['code_pattern'][trial_num]==1) stats.count('seq_correct');
            else stats.count('foil_correct');
            stats.hit_score(args[3]); // update the score
            if(cfg['adaptive_speed']!=0) Speeder.score_correct(trial_num);
            if(cfg['feedback']=='on' || cfg['feedback']=='pos' || cfg['feedback']=='all') activate_pos_flash(key_lane);
            if(cfg['feedback_remove_cue']=='all' || cfg['feedback_remove_cue']=='pos') cue_set[cue_index].active = false;
        }
        else if(event_type=='miss' || event_type=='err') {
            if(event_type=='err') {
                if (cue_index>=0) {
                    trial_num = cue_set[cue_index].trial_num;
                    cue_set[cue_index].scored = true;
                    if(cfg['adaptive_speed']!=0 && cue_set[cue_index].scored==false) Speeder.score_incorrect(trial_num); // only adjust speed if not scored already
                    if(cfg['feedback_remove_cue']=='all' || cfg['feedback_remove_cue']=='neg') cue_set[cue_index].active = false;
                }
                if(cfg['code_pattern'][trial_num]==1) stats.count('seq_incorrect');
                else stats.count('foil_incorrect');
            } else if(event_type=='miss'){   // this triggers if unscored cue leaves the screen
                trial_num=args[0];           // no cue index, so get trial num from args[0]
                if(cfg['adaptive_speed']!=0) Speeder.score_incorrect(trial_num);
                if(cfg['code_pattern'][trial_num]==1) stats.count('seq_incorrect');
                else stats.count('foil_incorrect');
                // for logging args is missing info about the code_pattern for scoring
                args.push('.',cfg['code_pattern'][trial_num],0.00);
            }
            if(key_lane>=0 && event_type=='err' && (cfg['feedback']=='on' || cfg['feedback']=='neg' || cfg['feedback']=='all'))
                activate_neg_flash(key_lane);
        }
        log_event(event_type,args);
    }

    // seems like this could be better integrated with the regular session_state update function instead of duplicating code
    function restart_session_state(trial_number) {
        session_state_counter=0;
        current_cue=0;
        while(session_state_counter<session.length) {
            var t = session[session_state_counter][0];
            if (t == "Trials:") {
                block_trial_max = current_cue+Number(session[session_state_counter][1]);
                if(trial_number<block_trial_max) { // this is the current block
                    current_cue=trial_number;
                    console.log("Restarting at cue "+current_cue);
                    session_state=8;
                    initialize_screen();
                    log_event('restart',[0]);
                    initialized=true;
                    stats.reset();
                    return;
                }
                current_cue=block_trial_max;  // update current cue and keep stepping through blocks
            }
            else if (t == "Disable_adaptive_timing:") { // needs testing
                cfg['adaptive_speed']=0;
            } else if (t == "Feedback:") { // needs testing
                cfg['feedback'] = session[session_state_counter][1];
            }
            session_state_counter++;
        }
        // experiment was already completed
        session_state=8;
    }

    function next_session_state() {
        if (session_state==8) {
            // restarting from return
            session_state=2;
            block_start = window.performance.now();
            last_launch = window.performance.now();
            log_event('block_restart',[0]);
            return;
        }
        session_state_counter++;
        if(session_state_counter>=session.length){ // all done with the session structure
            end_session();
            session_state=7;
            return;
        }
        var t = session[session_state_counter][0];
        if (t == "Break:") {    // Otherwise, session token type determines next state
            session_state = 1;
            break_image_file=session[session_state_counter][1];
        }
        else if (t == "Trials:") {
            session_state = 2;
            block_trial_max = current_cue+Number(session[session_state_counter][1]);
            stats.reset();

            // reset variables for the next block start
            block_start = window.performance.now();
            last_launch = window.performance.now();
            log_event('block_start',[0]);
        }
        else if (t == "Demo:") {
            session_state = 3;
        }
        else if (t == "Disable_adaptive_timing:") { // needs testing
            cfg['adaptive_speed']=0;
            next_session_state();
        } else if (t == "Feedback:") { // needs testing
            cfg['feedback']=session[session_state_counter][1];
            next_session_state();
            return;
        } else if (t == "Recognition:") {
            session_state = 4;
            Recognition.trial_num = 0;
            Recognition.trial_length = Number(session[session_state_counter][2]);  // does this work?  why isn't [1] used?
            Recognition.init_sequence(0);
            last_launch = window.performance.now();
            cfg['adaptive_speed']=0; // don't slow down on misses in recognition test
        } else if (t == "SetSpeed:") {
            current_speed = Number(session[session_state_counter][1]);
            next_session_state();
            return;
        }
    }

    // Main draw loop: State variables
        // state 0: initialize, load config, parse, preloading images
        // state 0.5: [not needed?]
        // state 1: Break message
        // state 2: Trials
        // state 3: Demo -- Deprecated for online version
        // state 4: Recognition test -- showing a short sequence with no feedback
        // state 5: Waiting for recognition response
        // state 6: in demo (used for keyboard handler)
        // state 7: completed
        // state 8: restart/return

        // To do:
        //    Progress_bar_off
        //    Feedback_text_off

    function end_block() {
        if(current_cue<block_trial_max) { // block end was forced
            current_cue=block_trial_max;
        }
        if (!upload_in_progress) { // to keep this from being re-run by draw() if the upload lags due to connection issues
            upload_in_progress=true;
            ServerHelper.upload_data('partial',response_log);
            var status_log=["Trial: "+current_cue.toString(),"Speed: "+current_speed.toString(),"Date: "+new Date().toString()];
            ServerHelper.upload_data('status',status_log);
            upload_in_progress=false;
        }
        cue_set=[];
        next_session_state();
    }

    function draw(){
        var curr_time=window.performance.now();
        var elap = (curr_time-last_launch)/1000.0;  // seconds since last cue launch

        layout.clear();
        if(session_state==0){      // before start
            log_event('begin',[0]);
            initialize_screen();   // initialize screen elements
            session_state_counter=0;
            current_cue=0;
            initialized=true;
            next_session_state();
        } else if(session_state==1){ // break
            var x = layout.width/2.0 - images[break_image_file].width/2.0;
            var y = layout.height/2.0 - images[break_image_file].height/2.0;
            ctx.drawImage(images[break_image_file],x,y);
        } else if(session_state==2) { // main sequence loop
            stats.fps_count();
            // redraw main screen elements
            for (var i=0;i<lane_set.length;i++) lane_set[i].draw_pad();
            // cue loop: check for launching new cues & move existing
            while (current_cue<block_trial_max && current_cue<cfg['cue_pattern'].length && elap >= (cfg['timing_pattern'][current_cue]*current_speed)) {
                launch_cue(cfg['cue_pattern'][current_cue], curr_time, current_cue, true);
                current_cue++;
                last_launch = curr_time;
                elap = 0.0;
            }
            var not_empty=false;
            for (i = 0; i < cue_set.length; i++) {
                if (cue_set[i].active == true) {
                    cue_set[i].move();
                    cue_set[i].draw();
                    not_empty=true;
                }
            }
            // anim loop, done in reverse order to be able to remove inactive items while drawing
            for (i = 0; i<anim_list.length; i++) if (anim_list[i].draw()) not_empty=true;
            if(not_empty==false && current_cue>=block_trial_max) end_block();
        }
        else if(session_state==3) { // show demo
            // Demo session_state is deprecated for online version -- to do: create demo for no sessionToken invocation
            next_session_state();
        } else if(session_state==4) {
            for (var i=0;i<lane_set.length;i++) lane_set[i].draw_pad();
            ctx.font = "24px Arial";

            ctx.fillStyle='black';
            ctx.textAlign="center";
            ctx.fillText("Watch the sequence",layout.cue_area/2.0,100); // y placement of recognition text should be smarter
            while (Recognition.current_cue<Recognition.trial_length && Recognition.current_cue<Recognition.cue_pattern.length &&
                    elap >= (Recognition.timing_pattern[Recognition.current_cue]*current_speed)) {
                launch_cue(Recognition.cue_pattern[Recognition.current_cue], curr_time, Recognition.current_cue, false);
                Recognition.current_cue++;
                last_launch = curr_time;
                elap = 0.0;
            }
            var not_empty=false;
            for (i = 0; i < cue_set.length; i++) {
                if (cue_set[i].active == true) {
                    cue_set[i].move();
                    cue_set[i].draw();
                    not_empty = true;
                }
            }
            if(not_empty==false && Recognition.current_cue>=Recognition.trial_length) {
                // Sequence has been displayed, get the response
                session_state=5;
            }
        } else if(session_state==5){
            for (var i=0;i<lane_set.length;i++) lane_set[i].draw_pad();
            ctx.font = "24px Arial";
            ctx.fillStyle='black';
            ctx.textAlign="center";
            ctx.fillText("Do you think you saw that sequence before?",layout.cue_area/2.0,layout.height/2.0-200);
            ctx.fillText("Use the number keys to answer, 1 to 9",layout.cue_area/2.0,layout.height/2.0-150);
            ctx.fillText("1=Sure never seen before, 9=Sure seen earlier",layout.cue_area/2.0,layout.height/2.0-100);
        }
        else if(session_state==8) {
            ctx.font = "24px Arial";
            ctx.fillStyle='black';
            ctx.textAlign="center";
            ctx.fillText("Welcome back",layout.cue_area/2.0,layout.height/2.0-200);
            ctx.fillText("Press a key to pick up where you left off",layout.cue_area/2.0,layout.height/2.0-150);
        }
        else { // unknown state
            ctx.font = "48px Arial";
            ctx.fillStyle='red';
            ctx.textAlign="center";
            ctx.fillText("Unknown state "+session_state_counter.toString(),layout.width/2.0,layout.height/2.0);
        }
        if(session_state!=7) {
            requestId = window.requestAnimationFrame(draw);
        }
    }

    var recognition_keys=['1','2','3','4','5','6','7','8','9'];
    function keypress(e){
        var k=String.fromCharCode(e.keyCode);

        if(session_state==4) {                   // recognition cues are moving, but no feedback
            if(e.keyCode==27) {
                // force end of sequence
                Recognition.current_cue=Recognition.trial_length;
            }
        } else if(session_state==5) {            // waiting for recognition score
            for(var i=0;i<recognition_keys.length && recognition_keys[i]!=k;i++);
            if(i<recognition_keys.length) { // allowable response
                // log response
                log_event('recognition', [Recognition.trial_num, i, cfg['recognition_codes'][Recognition.trial_num]]);
                // next recognition trial
                Recognition.trial_num++;
                if (Recognition.trial_num >= Number(session[session_state_counter][1])) {
                    // recognition test is over
                    next_session_state();
                } else {
                    Recognition.init_sequence(Recognition.trial_num);
                    session_state = 4;
                }
            }
        } else if(session_state==6) { // Demo mode: process response keys (normally? or with additional text feedback?)
            if(e.keyCode==27 || e.keyCode==13) { // ESC to terminate block
                demo_state=1;
                return;
            }
            var key_lane=-1;
            for(i=0;i<cfg['key_list'].length;i++) {
                if(k==cfg['key_list'][i]){
                    key_lane=i;
                    break;
                }
            }
            if (cue_set==[] || key_lane<0) return;
            // check if key pressed is associated with a lane
            var closest_distance=cue_set[0].distance; // first values are the first cue on the list
            var closest_index=0;
            for(var i=0;i<cue_set.length;i++){
                if(cue_set[i].active==true && cue_set[i].scored==false &&
                        cue_set[i].cue_lane==key_lane &&
                        cue_set[i].distance<cfg['target_cushion']) { // the key matches and the cue is in the target cushion, score hit
                    activate_pos_flash(key_lane); // amimate without scoring --- score_response('hit', i, key_lane, [cue_set[i].trial_num, k, cfg['code_pattern'][cue_set[i].trial_num], cue_set[i].distance.toFixed(3), cue_set[i].velocity[1]])
                    demo_correct++;
                    return;
                }
            }
            activate_neg_flash(key_lane);
            demo_count++;
            return;
        } else if(session_state!=2){ // Current state is waiting for a keypress to continue
            if(k=='Q') { // quick terminate from break screen if needed
                end_session();
                return;
            }
            next_session_state();
        }
        else { // Main loop: cues are moving, process response
            if(e.keyCode==27) { // ESC to terminate block
                end_block();
                return;
            }
            var key_lane=-1;
            for(i=0;i<cfg['key_list'].length;i++) {
                if(k==cfg['key_list'][i]){
                    key_lane=i;
                    break;
                }
            }
            if (cue_set==[] || key_lane<0) {// no cues are on screen
                score_response('err',-1,-1,[current_cue,k]);    // stray keypress
                return;
            }
            // check if key pressed is associated with a lane
            var closest_distance=layout.height;
            var closest_index=-1;
            for(var i=0;i<cue_set.length;i++){
                if(cue_set[i].active==true && cue_set[i].scored==false &&
                        cue_set[i].cue_lane==key_lane &&
                        cue_set[i].distance<cfg['target_cushion']) { // the key matches and the cue is in the target cushion, score hit
                    score_response('hit', i, key_lane, [cue_set[i].trial_num, k, cfg['code_pattern'][cue_set[i].trial_num], cue_set[i].distance.toFixed(3)]);
                    return;
                } else if(cue_set[i].active==true && cue_set[i].distance<closest_distance) { // find the closest cue
                    closest_distance=cue_set[i].distance;
                    closest_index=i;
                }
            }
            // here, the response was an error since nothing matched as a hit
            if (closest_index<0) score_response('err',-1,-1,[current_cue,k]);
            else score_response('err', closest_index, key_lane, [cue_set[closest_index].trial_num, k, cfg['code_pattern'][cue_set[closest_index].trial_num]]);
        }
    }

    var demo_state=0;
    var demo_count=0;
    var demo_correct=0;
    function sisl_demo(){
        demo_state=0;
        session_state=6;
        current_cue=0;
        last_launch=window.performance.now();

        // configuration overrides
        cfg['on_screen_feedback']="None";
        demo_count=0;
        demo_correct=0;
        initialize_screen();   // initialize screen elements
        stats.reset();
        requestId = window.requestAnimationFrame(demo_draw);
    }

    function demo_draw() {
        var curr_time=window.performance.now();
        var elap = (curr_time-last_launch)/1000.0;  // seconds since last cue launch

        layout.clear();
        if(demo_state==0) {
            ctx.font = "36px Arial";
            ctx.fillStyle = 'black';
            ctx.textAlign = "center";
            ctx.fillText("The SISL Experiment", layout.width / 2.0, 100);
            ctx.font = "24px Arial";
            if (demo_correct < 4) {
                ctx.fillText("When the circles move down the screen,", layout.width / 2.0, 150);
                ctx.fillText("Press the key underneath as it moves through the target.", layout.width / 2.0, 180);
                ctx.fillText("Circles will come quickly and", layout.width / 2.0, 210);
                ctx.fillText("speed up as you get better at the game.", layout.width / 2.0, 240);
                ctx.fillText("Demonstration Mode", layout.width / 2.0, 500);
                ctx.fillText("Do not sign up for this if you have done it before!", layout.width / 2.0, 540)
            } else {
                ctx.fillText("Good job!", layout.width / 2.0, 150);
                ctx.fillText("The experiment will last 30-60 minutes total.", layout.width / 2.0, 180);
                ctx.fillText("There will be breaks every few minutes as you go.", layout.width / 2.0, 210);
                ctx.fillText("The circles will speed up and slow down", layout.width / 2.0, 240);
                ctx.fillText("During the session so that it is always challenging", layout.width / 2.0, 270);
                ctx.fillText("But never impossible", layout.width / 2.0, 300);
                ctx.fillText("Press <Enter> when you are done with the demo", layout.width / 2.0, 500);
            }
            // single cue with keypress response
            for (var i=0;i<lane_set.length;i++) lane_set[i].draw_pad();
            // cue loop: check for launching new cues & move existing
            if (elap >= (cfg['timing_pattern'][current_cue]*current_speed)) {
                launch_cue(cfg['cue_pattern'][current_cue], curr_time, current_cue, true);
                current_cue++;
                if(current_cue>4) current_cue=0;
                last_launch = curr_time;
                elap = 0.0;
            }
            for (i = 0; i < cue_set.length; i++) {
                if (cue_set[i].active == true) {
                    cue_set[i].move();
                    cue_set[i].draw();
                }
            }
            // anim loop, done in reverse order to be able to remove inactive items while drawing
            for (i = 0; i<anim_list.length; i++) if (anim_list[i].draw()) not_empty=true;

        } else if(demo_state==1) {
            // demo is over, message and press space to quit out -- leave link to start for real? (not if blank mturk)
            console.log("Demo state 1");
            ctx.font = "36px Arial";
            ctx.fillStyle = 'black';
            ctx.textAlign = "center";
            ctx.fillText("The SISL Experiment", layout.width / 2.0, 100);
            ctx.fillText("That's all there is to it",layout.width/2.0,200);
            ctx.fillText("Sign up for an experiment session",layout.width/2.0,240);
            ctx.fillText("Whenever you are ready",layout.width/2.0,280);
            return;
        }
        requestId = window.requestAnimationFrame(demo_draw);
    }
    /*function mouseClick(e){ // currently this is only used for the consent acceptance
        var rect = canvas.getBoundingClientRect();
        x=e.clientX - rect.left;
        y=e.clientY - rect.top;
        if(session_state==0.5) {
            //console.log(e.clientX, e.clientY,x,y)
            if(y>450 && y<510) { // click is right height on screen
                if(x>200 && x<300) next_session_state(); // OK clicked
                else if(x>500 && x<600) terminate("Thanks anyway");
            }
        }
    }*/

    // response logging, SISL .txt format:
    // timestamp trial_num event_type lane_number speed [cue_pattern code_pattern offset]  -- last 3 only for key responses
    function log_event(event_type,args) { // args[0] always trial_num for event, others vary
        var elap = (window.performance.now() - block_start)/1000.0; // time stamp
        var line = elap.toFixed(2)+"\t"+args[0].toString()+"\t"+event_type+"\t";

        // if event time is a scored response, args[1]=lane, [2]=cue pattern, [3]=code pattern, [4]=offset
        // if it is a speed up event, args[2+] won't be there
        if (args[0]>=0 && args[0]<cfg['cue_pattern'].length)
            line+=cfg['cue_pattern'][args[0]].toString()+"\t"+current_speed.toFixed(2);
        else line+="0\t"+current_speed.toFixed(2);
        for(var i=1;i<args.length;i++) { line+="\t"+args[i].toString(); }  // any extra arguments
        response_log.push(line);
    }

    function initialize_screen() {
        for (var i = 0; i < cfg['num_keys']; i++) {
            start_loc = [cfg['start_x'][i], cfg['start_y'][i], cfg['start_z'][i]];
            target_loc = [cfg['target_x'][i], cfg['target_y'][i], cfg['target_z'][i]];
            delta = [cfg['delta_x'][i], cfg['delta_y'][i], cfg['delta_z'][i]];
            b = new lane(start_loc, target_loc, delta, cfg['cue_colors'][i], cfg['cue_size'], cfg['target_color'], cfg['target_diameter']);
            if (cfg['show_letters'] == 1) {
                b.add_letter(cfg['letter_x'][i], cfg['letter_y'][i], cfg['letter_color'], cfg['letter_size'], cfg['key_list'][i]);
            }
            lane_set.push(b);
            b.draw_pad();
        }
        // keys
        for (i = 0; i < cfg['key_list'].length; i++) {
            lane_set[i].key = cfg['key_list'][i];
        }
        // speeder
        if (cfg['adaptive_speed'] == 1) Speeder = new speed_adj(cfg['check_every'], cfg['percent_thresholds'], cfg['speed_fraction']);
        else Speeder = [];
        if (cfg.hasOwnProperty('time_to_elapse')) current_speed = cfg['time_to_elapse'];
        else current_speed = 1.5;

        // screen elements
        // x location is 150 from right edge
        var xloc_text=canvas.width-layout.feedback_area;
        if(typeof cfg['on_screen_feedback'] === 'string') {
            if (cfg['on_screen_feedback'] != 'None') {
                var a = new anim('text', 0, []);
                a.add_text(xloc_text, cfg['on_screen_feedback'], cfg['stat_text_size']);
                anim_list.push(a);
            }
        } else {
            for (i = 0; i < cfg['on_screen_feedback'].length; i++) {
                var a = new anim('text', 0, []);
                a.add_text(xloc_text, cfg['on_screen_feedback'][i], cfg['stat_text_size']);
                anim_list.push(a);
            }
        }

        // keypad flash animation objects
        for (i = 0; i < lane_set.length; i++) {
            a = new anim('flash-pos', cfg['feedback_frames'], [i, cfg['feedback_pos_color']]);
            a.active = false;
            a.dynamic = true;
            anim_list.push(a);
            a = new anim('flash-neg', cfg['feedback_frames'], [i, cfg['feedback_neg_color']]);
            a.active = false;
            a.dynamic = true;
            anim_list.push(a);
        }
    }

    function terminate(msg){
        window.cancelAnimationFrame(requestId);
        ctx.clearRect(0,0, 800, 800);
        ctx.font = "24px Arial";
        ctx.fillStyle='black';
        ctx.textAlign="center";
        lines=msg.split(';');
        for(i=0;i<lines.length;i++) {
            ctx.fillText(lines[i], 400, 300+i*30);
        }
        window.onbeforeunload = null;
    }

    function dataSummary() {
        var header=true;
        var hits=0;
        var misses=0;
        var errors=0;
        for(var i=0;i<response_log.length;i++) {
            if(response_log[i].slice(1,4)=="###") {
                header=false;
                console.log("End header in dataSummary");
            }
            else if(!header) {
                if(response_log[i].search('hit')>0) hits++;
                else if(response_log[i].search('err')>0) errors++;
                else if(response_log[i].search('miss')>0) misses++;
                else console.log(response_log[i]);
            }
        }
        var total=hits+misses+errors;
        var summary=total.toFixed(0)+"-trials-"+hits.toFixed(0)+"-hits-"+errors.toFixed(0)+"-errors-"+misses.toFixed(0)+"-misses";
        return summary;
    }

    function end_session() {
        if (!uploaded_final) {
            ServerHelper.upload_data('complete', response_log);
            if (ServerHelper.mturk) {
                ServerHelper.upload_to_mturk(dataSummary());
            }
            //if (cfg.hasOwnProperty('assignmentId') && cfg['assignmentId'] != '' &&
            //        cfg.hasOwnProperty('turkSubmitTo') && cfg['turkSubmitTo'] != '') {
            //    ServerHelper.upload_to_mturk(cfg['turkSubmitTo'], dataSummary()); // turkSubmitTo is parsed out of the original URL from mturk
            //}
            uploaded_final = true;
        }
        wait_upload_queue();
    }

    function wait_upload_queue() {
        if(ServerHelper.upload_in_progress) {
            ctx.clearRect(0, 0, layout.width, layout.height);
            ctx.font = "24px Arial";
            ctx.fillStyle = 'black';
            ctx.textAlign = "center";
            ctx.fillText("Uploading data...", layout.width / 2, (layout.height / 2) - 100);
            ctx.fillText("If this message stays for several minutes", layout.width / 2, layout.height / 2);
            ctx.fillText("please contact the experimenter", layout.width / 2, layout.height / 2 + 50);
            requestId = window.requestAnimationFrame(wait_upload_queue);
        }
        else {
            window.cancelAnimationFrame(requestId);
            finished()
        }
    }

    function finished() {
        window.removeEventListener("keydown", keypress, false);
        window.onbeforeunload = null;
        //window.removeEventListener("click",mouseClick, false);
        ctx.clearRect(0,0, layout.width,  layout.height);
        ctx.font = "24px Arial";
        ctx.fillStyle='black';
        ctx.textAlign="center";
        ctx.fillText("All done!", layout.width/2, (layout.height/2)-100);
        ctx.fillText("Thank you for participating", layout.width/2, layout.height/2);
        if (cfg_par_true('ShowStats')) {
            ctx.fillText("Performance from final block",layout.width/2,layout.height/2+100);
            ctx.fillText("Sequence % correct: "+stats.seq_pc.toFixed(1),layout.width/2,layout.height/2+130);
            ctx.fillText("Foil % correct: "+stats.foil_pc.toFixed(1),layout.width/2,layout.height/2+160);
            ctx.fillText("SSPA: "+stats.sspa.toFixed(2
                    ),layout.width/2,layout.height/2+190);
        }
    }

    // to do:
    // 5. Upload fps tracking for fidelity measure
    // 6. Dynamic events: floating text & progress bar

    // var consent_form={};

    function show_consent() {
        var form_holder = document.getElementById("formholder");
        consent_string="<h2>You are being asked to participate in a research study.  Please read and provide consent to participate before beginning.</h2><table class=\"consent\">";
        for(section in ServerHelper.consent_form) {
            consent_string+="<tr><td>"+section+"</td><td><b>"+ServerHelper.consent_form[section]+"</b></td></tr>"
        }
        consent_string+="</table><div id=\"acceptbutton\">Do you consent to participate in the experiment?<br></div>";
        form_holder.innerHTML=consent_string;
        b=document.createElement("input");
        b.type="button";
        b.value="I accept";
        b.addEventListener("click", consent_accepted);
        document.getElementById("acceptbutton").appendChild(b);
    }

    function consent_accepted() {
        var form_holder = document.getElementById("formholder");
        form_holder.innerHTML='';
        console.log("Consent accepted");
        document.getElementById("mainWin").focus();
        layout.clear();
        // test upload connection here...
        // to do: post test 'initial' event but wait for evidence that upload was successful before starting
        requestId = window.requestAnimationFrame(draw);
    }

    function config_validate() {
        var invalid=false;

        if(!cfg.hasOwnProperty('cue_pattern')) {
            terminate("Configuration error, please see Experimenter");
        }
        // use cfg['code_map'] to remap the cue_pattern to 0-index and check for validity of cues
        if (cfg.hasOwnProperty('code map')){
            for(i=0;i<cfg['cue_pattern'].length;i++) cfg['cue_pattern'][i]=cfg['code map'][cfg['cue_pattern']];
            for(i=0;i<cfg['recognition_pattern'].length;i++) cfg['recognition_pattern'][i]=cfg['code map'][cfg['recognition_pattern']];
        } else { // if no code map, assume 1-indexed for historical reasons
            for(i=0;i<cfg['cue_pattern'].length;i++) cfg['cue_pattern'][i]-=1;
            if(cfg.hasOwnProperty('recognition_pattern')){
                for (i = 0; i < cfg['recognition_pattern'].length; i++) cfg['recognition_pattern'][i] -= 1;
            }
        }

        // to do: check for invalid lane values, mismatched sequence lengths
        if(cfg['cue_pattern'].length>cfg['timing_pattern'].length || cfg['cue_pattern'].length>cfg['code_pattern'].length) invalid=true;

        if(invalid) terminate("Configuration Error.  Please contact experimenter.");

        // any needed but optional cfg values should be set here
        if(!cfg.hasOwnProperty('stat_text_size')) cfg['stat_text_size']=20;
    }

    function is_empty(o) {
        for(var k in o) return false;
        return true;
    }

    function cfg_par_true(p) {
        if (!cfg.hasOwnProperty(p)) return false;
        console.log(p+'; '+cfg[p]);
        if (cfg[p]==1 || cfg[p]=='1' || cfg[p]=='On' || cfg[p]=='True' || cfg[p]=='true' || cfg[p]=='yes' || cfg[p]=='Yes')
                return true;
        return false;
    }

    // preload kicks back to here after getting the cfg and images
    function start() {
        if (initialized) {
            config_validate();
            layout.clear();
            if(demo_mode) sisl_demo();
            else if(cfg.hasOwnProperty('status-trials') && !cfg_par_true('No-restart')) { // returning participant, could check for time since start -- unless no-restart is set...
                current_cue=cfg['status-trials'];
                if (cfg.hasOwnProperty('status-speed')) current_speed=cfg['status-speed'];
                // recalculate session_state counter and current_cue
                restart_session_state(cfg['status-trials']);
                if(session_state_counter>=session.length) {
                    // alert to already completed
                    terminate("You have already completed this experiment;Contact the Experimenter if you think this message is in error");
                    return;
                }
                requestId = window.requestAnimationFrame(draw);
            } else if(!is_empty(ServerHelper.consent_form)) show_consent();
            else requestId = window.requestAnimationFrame(draw);
        } else terminate("Initialization Error, please contact Experimenter");
    }

    function warn_termination() {
        // data and status upload
        ServerHelper.upload_data('partial',response_log);
        var status_log=["Trial: "+current_cue.toString(),"Speed: "+current_speed.toString(),"Date: "+new Date().toString()];
        ServerHelper.upload_data('status',status_log);
        return "Session not completed yet."
    }

    function main(){
        document.getElementById("mainWin").focus();
        var url=document.URL;

        // Prompt string is set assuming this means it was SONA scheduled
        ServerHelper.prompt_string="Please enter your SONA participant ID number"; //,"SONA_" + d
        var params=ServerHelper.empirical_start(url); // function in server.js to set up everything
        if (ServerHelper.fatal_error) {
            terminate(ServerHelper.error);
            return;
        }
        // add config parameters to cfg
        for (var p in params) cfg[p]=params[p];

        if (ServerHelper.demo_mode) {
            demo_mode=true;
            if (!cfg.hasOwnProperty('demo')) cfg['demo'] = 'true';
        }
        else {
            window.onbeforeunload=warn_termination;
        }

        if (initialized==false) { // if this gets run after initialization, something is off
            initialized=true;
            preload_experiment();
            //start();
        }
    }

    window.addEventListener("keydown",keypress,false);
    //canvas.addEventListener("click",mouseClick,false);

</script>

</body>
</html>
